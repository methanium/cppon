/*
 * C++ON - High performance C++17 JSON parser with extended features
 * https://github.com/methanium/cppon
 *
 * File: c++on-types.h : Core type definitions
 *
 * MIT License
 * Copyright (c) 2019-2025 Manuel Zaccaria (methanium) / CH5 Design
 *
 * See LICENSE file for complete license details
 */

#ifndef CPPON_TYPES_H
#define CPPON_TYPES_H

[[@UBER ? "" : "c++on-alternatives.h"]]
[[@UBER ? @STDCAPTURE : <type_traits>]]

namespace ch5 {

/**
 * @brief Central utilities for managing cppon objects and their interconnections.
 *
 * This suite of utility functions is foundational to the cppon framework. It manages the current root
 * context using a thread-local stack, provides a per-thread null sentinel, and enables consistent path
 * resolution across nested traversals while keeping threads isolated.
 *
 * - Root stack and accessors:
 *   - `push_root(const cppon&)` and `pop_root(const cppon&)`: Maintain a thread-local stack of roots.
 *     push_root() pushes the given object if it is not already at the top; pop_root() pops it only if
 *     it is the current top. This guarantees balanced push/pop in scoped contexts.
 *   - `get_root()`: Returns a reference to the current root. Asserts that the stack is non-empty and
 *     the top is non-null. Use this when resolving absolute paths or path_t values.
 *   - `root_guard`: RAII helper that pushes a root on construction and pops it on destruction, ensuring
 *     exception-safe stack balancing.
 *
 * - Invariants:
 *   - The root stack is thread_local and never empty (the bottom entry is a per-thread null sentinel).
 *   - The top entry must never be nullptr (enforced by assertions).
 *   - Each root must be unique within the stack (no duplicates allowed).
 *
 * - Absolute paths and operator[]:
 *   - When an index starts with '/', operator[] calls push_root(*this) and resolves the remainder of the
 *     path against `get_root()`. Prefer `root_guard` when switching the root for a scope.
 *
 * - `visitor(cppon&, size_t)`, `visitor(cppon&, string_view_t)`, `visitor(const cppon&, size_t)`, and
 *   `visitor(const cppon&, string_view_t)`: Provide mechanisms to access cppon objects by numeric index
 *   or string path. Resolution of `path_t` segments is performed against the current root.
 *
 * - Threading:
 *   - The root stack is per-thread (`thread_local`). Root changes are not visible across threads and
 *     do not require external synchronization.
 *
 * @note Lifetime: `cppon::~cppon()` calls `pop_root(*this)` to keep the stack consistent in the presence
 *       of temporaries or scoped objects.
 *
 * @warning Call `pop_root` only when you own the current top (typically via `root_guard` or the owning
 *          object's lifetime). Do not attempt to manually pop non-top entries.
 *
 * Collectively, these utilities underscore the cppon framework's flexibility, robustness, and capability to represent
 * and manage complex data structures and relationships. They are instrumental in ensuring that cppon objects can be
 * dynamically linked, accessed, and manipulated within a coherent and stable framework.
 */

namespace roots {
void push_root(const cppon& root);
void pop_root(const cppon& root) noexcept;
cppon& get_root() noexcept;
}//namespace roots
namespace visitors {
cppon& visitor(cppon& object, size_t index);
cppon& visitor(cppon& object, string_view_t index);
const cppon& visitor(const cppon& object, size_t index);
const cppon& visitor(const cppon& object, string_view_t index);
}//namespace visitors

class root_guard {
    cppon& new_root;
public:
    root_guard(const cppon& new_root_arg) noexcept
        : new_root(const_cast<cppon&>(new_root_arg)) {
        roots::push_root(new_root);
    }
    ~root_guard() noexcept {
        roots::pop_root(new_root);
    }
};

// Type trait to check if a type is contained in a std::variant and is an r-value reference
template<typename T, typename Variant>
struct is_in_variant_rv;

template<typename T, typename... Types>
struct is_in_variant_rv<T, std::variant<Types...>>
    : std::disjunction<std::is_same<std::decay_t<T>, Types>..., std::is_rvalue_reference<T>> {};

// Type trait to check if a type is contained in a std::variant and is an l-value reference
template<typename T, typename Variant>
struct is_in_variant_lv;

template<typename T, typename... Types>
struct is_in_variant_lv<T, std::variant<Types...>>
    : std::disjunction<std::is_same<std::decay_t<T>, Types>..., std::negation<std::is_rvalue_reference<T>>> {};

/**
 * @brief The cppon class represents a versatile container for various types used within the cppon framework.
 *
 * This class extends from `value_t`, which is an alias for a `std::variant` that encapsulates all types managed by cppon.
 * It provides several utility functions and operator overloads to facilitate dynamic type handling and hierarchical data
 * structure manipulation.
 *
 * - `is_null()`: Checks if the current instance holds a null value.
 *
 * - `operator[](index_t index)`: Overloaded subscript operators for non-const and const contexts. These operators allow
 *   access to nested cppon objects by index. If the root is null, the current instance is set as the root.
 *
 * - `operator=(const T& val)`: Template assignment operators for copying and moving values into the cppon instance.
 *
 * - `operator=(const char* val)`: Assignment operator for C-style strings, converting them to `string_view_t` before assignment.
 *
 * - `operator=(const string_t& val)`: Assignment operator for `string_t` type.
 *
 * The class leverages `std::visit` to handle the variant types dynamically, ensuring that the correct type-specific
 * operations are performed. This design allows cppon to manage complex data structures and relationships efficiently.
 */

class cppon : public value_t {
public:
    cppon() = default;
    cppon(const cppon&) = default;
    cppon(cppon&&) noexcept = default;
    ~cppon() noexcept { roots::pop_root(*this); }
    cppon& operator=(const cppon&) = default;
    cppon& operator=(cppon&&) noexcept = default;

    #if __cplusplus > 201703L
    // Implicit constructors for C++20

    // Containers
    cppon(array_t&& arr) : value_t(std::move(arr)) {}
    cppon(const array_t& arr) : value_t(arr) {}
    cppon(object_t&& obj) : value_t(std::move(obj)) {}
    cppon(const object_t& obj) : value_t(obj) {}

    // Litterals
    cppon(nullptr_t) : value_t(nullptr) {}
    cppon(boolean_t b) : value_t(b) {}

    // Numbers
    cppon(double_t d) : value_t(d) {}
    cppon(float_t f) : value_t(f) {}
    cppon(int8_t i8) : value_t(i8) {}
    cppon(uint8_t u8) : value_t(u8) {}
    cppon(int16_t i16) : value_t(i16) {}
    cppon(uint16_t u16) : value_t(u16) {}
    cppon(int32_t i32) : value_t(i32) {}
    cppon(uint32_t u32) : value_t(u32) {}
    cppon(int64_t i64) : value_t(i64) {}
    cppon(uint64_t u64) : value_t(u64) {}

    // Stringish and specific types
    cppon(const string_view_t& sv) : value_t(sv) {}
    cppon(string_t&& s) : value_t(std::move(s)) {}
    cppon(const string_t& s) : value_t(s) {}
    cppon(const number_t& n) : value_t(n) {}
    cppon(const path_t& p) : value_t(p) {}
    cppon(const blob_string_t& bs) : value_t(bs) {}
    cppon(blob_t&& b) : value_t(std::move(b)) {}
    cppon(const blob_t& b) : value_t(b) {}
    cppon(pointer_t ptr) : value_t(ptr) {}
    #endif // C++20

    /**
    * @brief Verifies that a cppon object is valid and throws an exception if it is not
    *
    * Helper that checks if a cppon object is not in the valueless_by_exception state,
    * throwing an explicit exception if it is. This prevents undefined behavior
    * by transforming a potential UB into a detectable logic error.
    *
    * @throws object_reference_lost_error if the object is invalid
    */
    inline bool check_valid() const noexcept {
        if (valueless_by_exception()) {
            CPPON_ASSERT(!"Reference lost: Object is in valueless_by_exception state");
            return false;
        }
        return true;
    }
    inline void ensure_valid() const {
        if (!check_valid()) throw object_reference_lost_error{ "Object is in valueless_by_exception state" };
    }

    inline auto is_null() const -> bool {
        ensure_valid();
        return std::holds_alternative<nullptr_t>(*this);
    }

    inline auto operator[](string_view_t index)->cppon& {
        ensure_valid();
        CPPON_ASSERT(!index.empty() && "Index cannot be empty");
        if (index.front() == '/') {
            roots::push_root(*this);
            return visitors::visitor(roots::get_root(), index.substr(1));
        }
        return visitors::visitor(*this, index);
    }

    inline auto operator[](string_view_t index)const->const cppon& {
        ensure_valid();
        CPPON_ASSERT(!index.empty() && "Index cannot be empty");
        if (index.front() == '/') {
            roots::push_root(*this);
            return visitors::visitor(static_cast<const cppon&>(roots::get_root()), index.substr(1));
        }
        return visitors::visitor(*this, index);
    }

    inline auto operator[](size_t index)->cppon& {
        ensure_valid();
        return visitors::visitor(*this, index);
    }

    inline auto operator[](size_t index)const->const cppon& {
        ensure_valid();
        return visitors::visitor(*this, index);
    }

    inline auto& operator=(const char* val) {
        ensure_valid();
        value_t::operator=(string_view_t{ val });
        return *this;
    }

    inline auto& operator=(pointer_t pointer) {
        ensure_valid();
        if (pointer && pointer->valueless_by_exception()) {
            throw unsafe_pointer_assignment_error(
                "RHS points to a valueless_by_exception object. "
                "Sequence the operation or use path_t"
            );
        }
        value_t::operator=( pointer );
        return *this;
    }

    // Template for lvalue references, disabled for types not contained in value_t
    template<
        typename T,
        typename = std::enable_if_t<is_in_variant_lv<T, value_t>::value>>
    inline auto& operator=(const T& val) {
        ensure_valid();
        value_t::operator=(val); return *this;
    }

    // Template for rvalue references, disabled for types not contained in value_t
    template<
        typename T,
        typename = std::enable_if_t<is_in_variant_rv<T, value_t>::value>>
    inline auto& operator=(T&& val) {
        ensure_valid();
        value_t::operator=(std::forward<T>(val)); return *this;
    }

    template<typename T,
        typename = std::enable_if_t<std::is_arithmetic_v<T>>>
    #ifndef CPPON_IMPLICIT_CONVERSION
    explicit
    #endif
    operator T() const {
        ensure_valid();
        return std::visit([this](auto&& arg) -> T {
            using type = std::decay_t<decltype(arg)>;
            if constexpr (std::is_arithmetic_v<type>)
                return static_cast<T>(arg);
            else if constexpr (std::is_same_v<type, number_t>) {
                auto temp = *this;
				convert_to_numeric(temp);
                return static_cast<T>(temp);
            }
            else
                throw type_mismatch_error{};
            }, static_cast<const value_t&>(*this));
    }

    template<typename T,
        typename = std::enable_if_t<std::is_arithmetic_v<T>>>
    #ifndef CPPON_IMPLICIT_CONVERSION
    explicit
    #endif
    operator T() {
        ensure_valid();
        return std::visit([this](auto&& arg) -> T {
            using type = std::decay_t<decltype(arg)>;
            if constexpr (std::is_arithmetic_v<type>)
                return static_cast<T>(arg);
            else if constexpr (std::is_same_v<type, number_t>) {
                auto temp = *this;
				convert_to_numeric(temp);
                return static_cast<T>(temp);
            }
            else
                throw type_mismatch_error{};
            }, static_cast<value_t&>(*this));
    }

    #ifndef CPPON_IMPLICIT_CONVERSION
    explicit
    #endif
    operator string_view_t() const {
        ensure_valid();
        return std::visit([](auto&& arg) -> string_view_t {
            using type = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<type, string_view_t> || std::is_same_v<type, number_t>)
                return arg;
            else if constexpr (std::is_same_v<type, string_t>)
                return string_view_t(arg);
            else
                throw type_mismatch_error{};
        }, static_cast<const value_t&>(*this));
    }

    #ifndef CPPON_IMPLICIT_CONVERSION
    explicit
    #endif
    operator string_view_t() {
        ensure_valid();
        return std::visit([](auto&& arg) -> string_view_t {
            using type = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<type, string_view_t> || std::is_same_v<type, number_t>)
                return arg;
            else if constexpr (std::is_same_v<type, string_t>)
                return string_view_t(arg);
            else
                throw type_mismatch_error{};
        }, static_cast<value_t&>(*this));
    }

    #ifndef CPPON_IMPLICIT_CONVERSION
    explicit
    #endif
    operator string_t() const {
        ensure_valid();
        return std::visit([](auto&& arg) -> string_t {
            using type = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<type, string_view_t> || std::is_same_v<type, number_t>)
                return string_t(arg);
            else if constexpr (std::is_same_v<type, string_t>)
                return arg;
            else if constexpr (std::is_arithmetic_v<type>) {
                return std::to_string(arg);
            }
            else
                throw type_mismatch_error{};
        }, static_cast<const value_t&>(*this));
    }

    #ifndef CPPON_IMPLICIT_CONVERSION
    explicit
    #endif
    operator string_t() {
        ensure_valid();
        return std::visit([](auto&& arg) -> string_t {
            using type = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<type, string_view_t> || std::is_same_v<type, number_t>)
                return string_t(arg);
            else if constexpr (std::is_same_v<type, string_t>)
                return arg;
            else if constexpr (std::is_arithmetic_v<type>) {
                return std::to_string(arg);
            }
            else
                throw type_mismatch_error{};
        }, static_cast<value_t&>(*this));
    }
    
    // Underlying container access (throws type_mismatch_error on wrong type)
    inline auto array() -> array_t& {
        ensure_valid();
        if (auto p = std::get_if<array_t>(this)) return *p;
        throw type_mismatch_error{ "array_t expected" };
    }
    inline auto array() const -> const array_t& {
        ensure_valid();
        if (auto p = std::get_if<array_t>(this)) return *p;
        throw type_mismatch_error{ "array_t expected" };
    }
    inline auto object() -> object_t& {
        ensure_valid();
        if (auto p = std::get_if<object_t>(this)) return *p;
        throw type_mismatch_error{ "object_t expected" };
    }
    inline auto object() const -> const object_t& {
        ensure_valid();
        if (auto p = std::get_if<object_t>(this)) return *p;
        throw type_mismatch_error{ "object_t expected" };
    }

    // Optional non-throw helpers
    inline auto try_array() noexcept -> array_t* { return check_valid() ? std::get_if<array_t>(this) : nullptr; }
    inline auto try_array() const noexcept -> const array_t* { return check_valid() ? std::get_if<array_t>(this) : nullptr; }
    inline auto try_object() noexcept -> object_t* { return check_valid() ? std::get_if<object_t>(this) : nullptr; }
    inline auto try_object() const noexcept -> const object_t* { return check_valid() ? std::get_if<object_t>(this) : nullptr; }

    // Array iteration
    inline auto begin() { return array().begin(); }
    inline auto end() { return array().end(); }
    inline auto begin() const{ return array().begin(); }
    inline auto end() const { return array().end(); }
};

template<
    typename T,
    typename = std::enable_if_t<is_in_variant_lv<T, value_t>::value>>
inline bool operator==(const cppon& lhs, const T& rhs) noexcept {
    if (lhs.valueless_by_exception())
        return false;

    // Vérifier si le type stocké correspond à T
    const T* val = std::get_if<T>(&lhs);
    if (!val)
        return false;

    // Comparer les valeurs
    return *val == rhs;
}
template<
    typename T,
    typename = std::enable_if_t<is_in_variant_lv<T, value_t>::value>>
inline bool operator==(const T& lhs, const cppon& rhs) noexcept {
    if (rhs.valueless_by_exception())
        return false;

    // Vérifier si le type stocké correspond à T
    const T* val = std::get_if<T>(&rhs);
    if (!val)
        return false;

    // Comparer les valeurs
    return lhs == *val;
}

template<
    typename T,
    typename = std::enable_if_t<is_in_variant_lv<T, value_t>::value>>
inline bool operator!=(const cppon& lhs, const T& rhs) noexcept {
    return !(lhs == rhs);
}
template<
    typename T,
    typename = std::enable_if_t<is_in_variant_lv<T, value_t>::value>>
inline bool operator!=(const T& lhs, const cppon& rhs) noexcept {
    return !(lhs == rhs);
}

#ifdef CPPON_ENABLE_STD_GET_INJECTION
using std::get_if;
using std::get;
#endif

}//namespace ch5

#endif //CPPON_TYPES_H
