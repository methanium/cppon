/*
 * C++ON - High performance C++17 JSON parser with extended features
 * https://github.com/methanium/cppon
 *
 * File: c++on-swar.h : C++ON SIMD Within A Register (SWAR) utilities
 *
 * MIT License
 * Copyright (c) 2019-2025 Manuel Zaccaria (methanium) / CH5 Design
 *
 * See LICENSE file for complete license details
 */

#ifndef CPPON_SWAR_H
#define CPPON_SWAR_H

[[@UBER ? @STDCAPTURE : <string_view>]]
[[@UBER ? @STDCAPTURE : <limits>]]
[[@UBER ? @STDCAPTURE : <cstdint>]]
[[@UBER ? @STDCAPTURE : <cstring>]]
[[@UBER ? @STDCAPTURE : <cassert>]]

namespace ch5 {

// SWAR constants
constexpr uint64_t kOnes = 0x0101010101010101ULL;   // (~0ULL / 255)
constexpr uint64_t kHigh = 0x8080808080808080ULL;   // (~0ULL / 255) * 128

inline uint64_t m64_load_aligned(const char* p) noexcept {
    assert((reinterpret_cast<uintptr_t>(p) & 7u) == 0 && "Pointer must be 8-byte aligned for m64 load");
    return *reinterpret_cast<const uint64_t*>(p);
}
inline uint64_t m64_load_unaligned(const char* p) noexcept {
    uint64_t v; std::memcpy(&v, p, sizeof(v)); return v;
}

inline uint64_t m64_load_aligned(std::string_view Text, size_t Ofs = 0) noexcept {
	assert(Text.size() >= Ofs + 8);
    return m64_load_aligned(Text.data() + Ofs);
}
inline uint64_t m64_load_unaligned(std::string_view Text, size_t Ofs = 0) noexcept {
    assert(Text.size() >= Ofs + 8);
    return m64_load_unaligned(Text.data() + Ofs);
}

constexpr inline uint64_t byte_mask(uint8_t b) noexcept { return uint64_t(b) * kOnes; }
constexpr inline uint64_t zero_byte_mask(uint64_t v) noexcept { return uint64_t((v - kOnes) & ~v) & kHigh; }
constexpr inline uint64_t lt_byte_mask(uint64_t x, uint8_t n) noexcept { return (x - byte_mask(n)) & kHigh; }
constexpr inline uint64_t gt_byte_mask(uint64_t x, uint8_t n) noexcept { return (byte_mask(n) - x) & kHigh; }
constexpr inline uint64_t eq_byte_mask(uint64_t x, uint8_t b) noexcept { return zero_byte_mask(x ^ byte_mask(b)); }

// Outside ['0'..'9']
constexpr inline uint64_t not_digit_mask(uint64_t x) noexcept {
    return (lt_byte_mask(x, '0') | gt_byte_mask(x, '9'));
}

// Non-space mask (high bit set where byte is NOT a space)
constexpr inline uint64_t not_space_mask(uint64_t x) noexcept {
#ifndef CPPON_TRUSTED_INPUT
    // JSON strict spaces: ' ', '\t', '\n', '\r'
    const uint64_t ws =
            (eq_byte_mask(x, static_cast<uint8_t>(' ')) |
            eq_byte_mask(x, static_cast<uint8_t>('\t')) |
            eq_byte_mask(x, static_cast<uint8_t>('\n')) |
            eq_byte_mask(x, static_cast<uint8_t>('\r')));
    return (~ws) & kHigh;
#else
    // Trusted input: whitespace 0x01..0x20 (non-zero controls). Test: (c-1) < 0x20 â‡’ space
    const uint64_t y = x - kOnes;                  // c - 1
    const uint64_t ws = gt_byte_mask(y, 0x1fu);    // high bit if (c-1) >= 0x20
    return ws & kHigh;                             // high bit if NOT space
#endif
}

constexpr inline bool has_zero_byte(uint64_t v) noexcept { return zero_byte_mask(v) != 0; }
constexpr inline bool has_byte_less_than(uint64_t x, int8_t n) noexcept { return lt_byte_mask(x, static_cast<uint8_t>(n)) != 0; }
constexpr inline bool has_byte_greater_than(uint64_t x, int8_t n) noexcept { return gt_byte_mask(x, static_cast<uint8_t>(n)) != 0; }
constexpr inline bool has_byte(uint64_t x, int8_t b) noexcept { return eq_byte_mask(x, static_cast<uint8_t>(b)) != 0; }

constexpr int m64_npos = 8;

inline auto m64_get_first_match(uint64_t Mask) {
    if (Mask == 0)
        return m64_npos;
    #if defined(_MSC_VER)
    unsigned long tz; _BitScanForward64(&tz, Mask); return static_cast<int>(tz >> 3);
    #else
    return static_cast<int>(static_cast<unsigned>(__builtin_ctzll(Mask)) >> 3);
    #endif
    }

/**
 * SWAR parallel comparison functions
 */
inline const char* m64_parallel_digits(std::string_view Text, size_t Ofs, size_t Count) noexcept {
    assert(Text.size() >= Ofs + Count);
    const char* p   = Text.data() + Ofs;
    const char* end = Text.data() + Ofs + Count;

    // Align
    //while (p <= end && (reinterpret_cast<uintptr_t>(p) & 7u)) {
    //    const unsigned char c = static_cast<unsigned char>(*p);
    //    if ((c - 0x30u) > 0x09u) return p;
    //    ++p;
    //}
    // Aligned Words
    while (p + 8 <= end) {
        uint64_t w = m64_load_unaligned(p);
        uint64_t mask = not_digit_mask(w);
        if (mask) {
            return p + m64_get_first_match(mask);
        }
        p += 8;
    }
    // Unaligned Tail
    while (p <= end) {
        const unsigned char c = static_cast<unsigned char>(*p);
        if ((c - 0x30u) > 0x09u) return p;
        ++p;
    }
    return nullptr;
}
inline const char* m64_parallel_digits(std::string_view Text, size_t Ofs) noexcept {
    return m64_parallel_digits(Text, Ofs, Text.size() - Ofs);
}
inline const char* m64_parallel_digits(std::string_view Text) noexcept {
    return m64_parallel_digits(Text, 0, Text.size());
}

inline const char* m64_parallel_find_quote(std::string_view Text, size_t Ofs, size_t Count) noexcept {
	assert(Text.size() >= Ofs + Count);
    const char* p = Text.data() + Ofs;
    const char* end = Text.data() + Ofs + Count;

    // Align to 8 bytes
    //while (p < end && (reinterpret_cast<uintptr_t>(p) & 7u)) {
    //    if (*p == '"') return p;
    //    ++p;
    //}
    // Aaligned Words
    while (p + 8 <= end) {
        uint64_t w = m64_load_unaligned(p);
        uint64_t mask = eq_byte_mask(w, static_cast<uint8_t>('"'));
        if (mask) {
            return p + m64_get_first_match(mask);
        }
        p += 8;
    }
    // Unaligned Tail
    while (p < end) {
        if (*p == '"') return p;
        ++p;
    }
    return nullptr;
}
inline const char* m64_parallel_find_quote(std::string_view Text, size_t Ofs) noexcept {
    return m64_parallel_find_quote(Text, Ofs, Text.size() - Ofs);
}
inline const char* m64_parallel_find_quote(std::string_view Text) noexcept {
    return m64_parallel_find_quote(Text, 0, Text.size());
}

inline const char* m64_parallel_skip_spaces(std::string_view Text, size_t Ofs, size_t Count) noexcept {
    assert(Text.size() >= Ofs + Count);
    const char* p = Text.data() + Ofs;
    const char* end = Text.data() + Ofs + Count;

    // Align
    //while (p < end && (reinterpret_cast<uintptr_t>(p) & 7u)) {
    //    const unsigned char c = static_cast<unsigned char>(*p);
    //    #ifndef CPPON_TRUSTED_INPUT
    //    if (c != 0x20 && c != '\t' && c != '\n' && c != '\r') return p;
    //    #else
    //    if ((c - 1u) >= 0x20) return p;
    //    #endif
    //    ++p;
    //}
    // Aligned Words
    while (p + 8 <= end) {
        uint64_t w = m64_load_unaligned(p);
        uint64_t mask = not_space_mask(w);
        if (mask) { // Not all spaces
            return p + m64_get_first_match(mask);
        }
        p += 8;
    }
    // Unaligned Tail
    while (p < end) {
        const unsigned char c = static_cast<unsigned char>(*p);
        #ifndef CPPON_TRUSTED_INPUT
        if (c != 0x20 && c != '\t' && c != '\n' && c != '\r') return p;
        #else
        if ((c - 1u) >= 0x20) return p;
        #endif
        ++p;
    }
    return nullptr;
}
inline const char* m64_parallel_skip_spaces(std::string_view Text, size_t Ofs) noexcept {
    return m64_parallel_skip_spaces(Text, Ofs, Text.size() - Ofs);
}
inline const char* m64_parallel_skip_spaces(std::string_view Text) noexcept {
    return m64_parallel_skip_spaces(Text, 0, Text.size());
}

inline size_t m64_parallel_digits_pos(std::string_view Text, size_t Ofs, size_t Count) noexcept {
    assert(Text.size() >= Ofs + Count);
    const char* Found = m64_parallel_digits(Text, Ofs, Count);
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}
inline size_t m64_parallel_digits_pos(std::string_view Text, size_t Ofs) noexcept {
    assert(Text.size() >= Ofs);
    const char* Found = m64_parallel_digits(Text, Ofs, Text.size() - Ofs);
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}
inline size_t m64_parallel_digits_pos(std::string_view Text) noexcept {
    const char* Found = m64_parallel_digits(Text, 0, Text.size());
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}

inline size_t m64_parallel_find_quote_pos(std::string_view Text, size_t Ofs, size_t Count) noexcept {
    assert(Text.size() >= Ofs + Count);
    const char* Found = m64_parallel_find_quote(Text, Ofs, Count);
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}
inline size_t m64_parallel_find_quote_pos(std::string_view Text, size_t Ofs) noexcept {
    assert(Text.size() >= Ofs);
    const char* Found = m64_parallel_find_quote(Text, Ofs, Text.size() - Ofs);
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}
inline size_t m64_parallel_find_quote_pos(std::string_view Text) noexcept {
    const char* Found = m64_parallel_find_quote(Text, 0, Text.size());
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}

inline size_t m64_parallel_skip_spaces_pos(std::string_view Text, size_t Ofs, size_t Count) noexcept {
    assert(Text.size() >= Ofs + Count);
    const char* Found = m64_parallel_skip_spaces(Text, Ofs, Count);
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}
inline size_t m64_parallel_skip_spaces_pos(std::string_view Text, size_t Ofs) noexcept {
    assert(Text.size() >= Ofs);
    const char* Found = m64_parallel_skip_spaces(Text, Ofs, Text.size() - Ofs);
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}
inline size_t m64_parallel_skip_spaces_pos(std::string_view Text) noexcept {
    const char* Found = m64_parallel_skip_spaces(Text, 0, Text.size());
    return Found ? static_cast<size_t>(Found - Text.data()) : Text.npos;
}

} // namespace ch5

#endif // CPPON_SWAR_H
